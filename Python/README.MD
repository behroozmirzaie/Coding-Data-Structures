# سطح junior

۱- چند ویژگی پایتون را نام ببرید؟

پایتون یک زبان تفسیری (interpreted language) است. بدان معناست که برخلاف زبان‌هایی مانند C و انواع آن، پایتون قبل از اجرا نیازی به کامپایل ندارد. سایر زبان های تفسیری عبارتند از PHP و Ruby.

پایتون به صورت Dynamically Typed است، به این معنی که شما نیازی به بیان انواع متغیرها در هنگام تعریف آنها یا هر چیز دیگری ندارید. می توانید کارهایی مانند x=111 و سپس x="I'm a string" را بدون خطا انجام دهید


پایتون برای برنامه نویسی شی گرا مناسب است زیرا امکان تعریف کلاس ها به همراه composition و inheritance را فراهم می کند. پایتون مشخص‌کننده‌های دسترسی ندارد (مانند public, private)، توجیه این نکته به این صورت است که "ما همه در اینجا بزرگسال هستیم". "we are all adults here"

در پایتون، توابع اشیاء درجه یک هستند(functions are first-class objects). بدان معنی است که می توان آنها را به متغیرها نسبت داد، از توابع دیگر برگرداند و به توابع منتقل کرد. کلاس ها نیز اشیاء درجه یک هستند.


نوشتن کد در پایتون سریع است اما اجرای آن اغلب کندتر از زبان های کامپایل شده است.

---


۲- چگونه یک string را modify میکنید؟

شما نمی توانید زیرا رشته ها تغییر ناپذیر(immutable) هستند. در اکثر مواقع، باید کارکتر هایی که مدر نظر هستند را جدا کرده و یک لیست جدید از آنها بسازیم و در صورت نیاز آنها را تبدیل به رشته کنیم.

```
>>> s = list("Hello zorld")
>>> s
['H', 'e', 'l', 'l', 'o', ' ', 'z', 'o', 'r', 'l', 'd']
>>> s[6] = 'W'
>>> s
['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
>>> "".join(s)
'Hello World'
```
---

۳- انواع built-in types در پایتون چیست؟

نوع های تغییر ناپذیر

اعداد: int, float, complex

دنباله ها: str, tuple, frozenset, bytes

نوع های تغییر پذیر

انواع list, set, dict, class, …

این موضوع را باید درک کنید که python تمام اینها را به عنوان object معرفی می کند.

---

۴- توضیح دهید که جستجوی خطی (متوالی)  Linear چیست و چه زمانی می توانیم از آن استفاده کنیم؟

جستجوی خطی (متوالی) همه عناصر ممکن را در یک آرایه به صورت پشت سرهم بررسی می کند و هر کدام از عناصر  را با عنصر مورد نظر مقایسه می کند. ممکن است تا عملیات O(n) طول بکشد، که در آن N اندازه یک آرایه است.

در موارد زیر میتوان استفاده کرد:

عملیات جستجو را فقط یک بار انجام می دهید.

امکان rearrange کردن عناصر آرایه را نداریم و هیچ گونه memory اضافه ای نداریم.

اندازه array کوچک است. یا کلا performance برای ما اهمیت ندارد.

حتی اگر در تئوری دیگر الگوریتم‌های جستجو ممکن است سریع‌تر از جستجوی خطی باشند (مثلاً جستجوی دودویی)، در عمل حتی در آرایه‌های با اندازه متوسط (حدود 100 مورد یا کمتر) ممکن است استفاده ازهر روش  دیگری غیرممکن باشد. در آرایه‌های بزرگ‌تر، تنها زمانی استفاده از روش‌های جستجوی سریع‌تر دیگر منطقی است که داده‌ها به اندازه کافی بزرگ باشند، زیرا زمان اولیه برای آماده‌سازی (مرتب‌سازی) داده‌ها با بسیاری از جستجوهای خطی قابل مقایسه است.

زمانی که نمیدونیم دقیقا دنبال چه چیزی میگردیم.

وقتی از MySQL چیزی شبیه SELECT x FROM y می‌پرسید که z = t و z ستونی بدون فهرست است، جستجوی خطی با تمام پیامدهای آن انجام می‌شود. به همین دلیل است که افزودن فهرست به ستون های قابل جستجو مهم است.

جستجوی خطی در بدترین linear time  انجام می‌شود و حداکثر n مقایسه را انجام می‌دهد، جایی که n طول لیست است. اگر احتمال جستجوی هر عنصر به یک اندازه باشد، جستجوی خطی دارای یک مورد متوسط از (n+1)/2 مقایسه است، اما اگر احتمالات جستجو برای هر عنصر متفاوت باشد، میانگین مورد می تواند تحت تأثیر قرار گیرد.


```
# can be simply done using 'in' operator
if x in arr:
   print arr.index(x)
 
# If you want to implement Linear Search in Python
def search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
 
    return -1

```

---

۵- متغیرهای محلی و متغیرهای سراسری در پایتون چیست؟ global vs local variables

متغیرهای سراسری: متغیرهایی که خارج از یک تابع یا در فضای global اعلام می شوند، متغیرهای سراسری نامیده می شوند. این متغیرها توسط هر تابعی در برنامه قابل دسترسی هستند.

متغیرهای محلی: هر متغیری که در داخل یک تابع اعلام شود به عنوان متغیر local شناخته می شود. این متغیر در فضای محلی وجود دارد نه در فضای global.

---

۶- توصیفگرها چیست؟ descriptors

توصیفگرها در نسخه 2.2 به پایتون معرفی شدند. آنها به توسعه دهنده توانایی اضافه کردن ویژگی های مدیریت شده به اشیاء را می دهند.( managed attributes to objects) روش های مورد نیاز برای ایجاد یک توصیفگر، __get__، __set__ و __delete__ هستند. اگر هر یک از این روش ها را تعریف کنید، یک توصیفگر ایجاد کرده اید.

---

۷- آیا پایتون دستور switch-case دارد؟

در پایتون قبل از 3.10، دستور switch-case نداریم. در اینجا، می توانید یک تابع سوئیچ برای این منظور بنویسید. در غیر این صورت، می توانید از مجموعه ای از عبارات if-elif-else استفاده کنید. برای پیاده سازی تابعی برای انجام این کار، احتمالا از دیکشنری استفاده می کنیم.

```
def switch_demo(argument):
    switcher = {
        1: "January",
        2: "February",
        3: "March",
        4: "April",
        5: "May",
        6: "June",
        7: "July",
        8: "August",
        9: "September",
        10: "October",
        11: "November",
        12: "December"
    }
    print switcher.get(argument, "Invalid month")

```

در سال ۲۰۲۱ پایتون در ورژن 3.10 عبارت match-case را معرفی کرد. برای مثال:

```
def f(x):
    match x:
        case 'a':
            return 1
        case 'b':
            return 2

```

عبارت match-case بسیار قدرتمندتر از این مثال ساده است.

---

۸- چه زمانی از tuple, list, dictionary استفاده می کنیم؟

از tuple زمانی که یک مجموعه از داده هایی که تغییر نخواهند کرد استفاده می کنیم.

از list زمانی که یک مجموعه از داده هایی که تغییر خواهند کرد استفاده میکنیم.

زمانی که می‌خواهید جفت‌هایی از دو مورد را به هم مرتبط کنید، از dictionary استفاده میکنیم.

---

۹- ایندکس منفی در پایتون به چه معنی است؟

ایندکس اعداد منفی به این معنی است که شما به جای چپ، از راست می‌شمارید. بنابراین، list[-1] به آخرین عنصر اشاره می کند.

---

۱۰- توابع Lambda در پایتون چیست؟

یک تابع Lambda یک تابع ناشناس کوچک است. یک تابع Lambda می تواند هر تعداد آرگومان را بگیرد، اما فقط می تواند یک عبارت داشته باشد. (many agruments but only one expression)

```
x = lambda a : a + 10
print(x(5)) # Output: 15

```

--- 
# سطح Mid

۱۱- نحوه عملکرد مدیریت حافظه پایتون را توضیح دهید؟

پایتون - مانند سی شارپ، جاوا و بسیاری از زبان های دیگر - به جای مدیریت دستی حافظه از garbage collection  استفاده می کند. شما فقط آزادانه اشیاء را ایجاد می کنید و مدیر حافظه به صورت دوره ای (یا زمانی که به طور خاص آن را هدایت می کنید) به دنبال اشیایی می گردد که دیگر توسط برنامه شما ارجاع داده نمی شود.

اگر میخواهید یک شیء را نگه دارید، کافی ایست یک instance از آن نگه دارید. اگر میخواهید شیء آزاد شود تمام refrenced هایی که به آن شیء دارید را حذف کنید.

---

۱۲- چرا از عبارت pass استفاده می کنیم؟

پایتون قانونی دارد که بلاک های کد نمی توانند خالی باشند. با این حال، بلوک‌های خالی در زمینه‌های مختلف مفید هستند، برای مثال، اگر در حال طراحی یک کلاس جدید با روش‌هایی هستید که نمی‌خواهید پیاده‌سازی کنید:

```
class MyClass(object):
    def meth_a(self):
        pass

    def meth_b(self):
        print "I'm meth_b"

```
اگر بخواهید پاس را حذف کنید، کد اجرا نمی شود و با یک خطا مواجه می شوید:

```
IndentationError: expected an indented block

```

مثال‌ دیگری که می‌توانیم از paas استفاده کنیم:

نادیده گرفتن (همه یا) نوع خاصی از استثناها

---


