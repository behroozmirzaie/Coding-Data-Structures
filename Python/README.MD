# سطح junior

۱- چند ویژگی پایتون را نام ببرید؟

پایتون یک زبان مفسری (interpreted language) است. بدان معناست که برخلاف زبان‌هایی مانند C و انواع آن، پایتون قبل از اجرا
نیازی به کامپایل ندارد. سایر زبان های تفسیری عبارتند از PHP و Ruby.

پایتون به صورت Dynamically Typed است، به این معنی که شما نیازی به بیان انواع متغیرها در هنگام تعریف آنها یا هر چیز دیگری
ندارید. می توانید کارهایی مانند x=111 و سپس x="I'm a string" را بدون خطا انجام دهید

پایتون برای برنامه نویسی شی گرا مناسب است زیرا امکان تعریف کلاس ها به همراه composition و inheritance را فراهم می کند.
پایتون مشخص‌کننده‌های دسترسی ندارد (مانند public, private)، توجیه این نکته به این صورت است که "ما همه در اینجا بزرگسال
هستیم". "we are all adults here"

در پایتون، توابع اشیاء درجه یک هستند(functions are first-class objects). بدان معنی است که می توان آنها را به متغیرها
نسبت داد، از توابع دیگر برگرداند و به توابع منتقل کرد. کلاس ها نیز اشیاء درجه یک هستند.

نوشتن کد در پایتون سریع است اما اجرای آن اغلب کندتر از زبان های کامپایل شده است.

---


۲- چگونه یک string را modify میکنید؟

شما نمی توانید زیرا رشته ها تغییر ناپذیر(immutable) هستند. در اکثر مواقع، باید کارکتر هایی که مدر نظر هستند را جدا کرده
و یک لیست جدید از آنها بسازیم و در صورت نیاز آنها را تبدیل به رشته کنیم.

```
>>> s = list("Hello zorld")
>>> s
['H', 'e', 'l', 'l', 'o', ' ', 'z', 'o', 'r', 'l', 'd']
>>> s[6] = 'W'
>>> s
['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
>>> "".join(s)
'Hello World'
```

---

۳- انواع built-in types در پایتون چیست؟

نوع های تغییر ناپذیر

اعداد: int, float, complex

دنباله ها: str, tuple, frozenset, bytes

نوع های تغییر پذیر

انواع list, set, dict, class, …

این موضوع را باید درک کنید که python تمام اینها را به عنوان object معرفی می کند.

---

۴- توضیح دهید که جستجوی خطی (متوالی) Linear چیست و چه زمانی می توانیم از آن استفاده کنیم؟

جستجوی خطی (متوالی) همه عناصر ممکن را در یک آرایه به صورت پشت سرهم بررسی می کند و هر کدام از عناصر را با عنصر مورد نظر
مقایسه می کند. ممکن است تا عملیات O(n) طول بکشد، که در آن N اندازه یک آرایه است.

در موارد زیر میتوان استفاده کرد:

عملیات جستجو را فقط یک بار انجام می دهید.

امکان rearrange کردن عناصر آرایه را نداریم و هیچ گونه memory اضافه ای نداریم.

اندازه array کوچک است. یا کلا performance برای ما اهمیت ندارد.

حتی اگر در تئوری دیگر الگوریتم‌های جستجو ممکن است سریع‌تر از جستجوی خطی باشند (مثلاً جستجوی دودویی)، در عمل حتی در
آرایه‌های با اندازه متوسط (حدود 100 مورد یا کمتر) ممکن است استفاده ازهر روش دیگری غیرممکن باشد. در آرایه‌های بزرگ‌تر،
تنها زمانی استفاده از روش‌های جستجوی سریع‌تر دیگر منطقی است که داده‌ها به اندازه کافی بزرگ باشند، زیرا زمان اولیه برای
آماده‌سازی (مرتب‌سازی) داده‌ها با بسیاری از جستجوهای خطی قابل مقایسه است.

زمانی که نمیدونیم دقیقا دنبال چه چیزی میگردیم.

جستجوی خطی در بدترین linear time انجام می‌شود و حداکثر n مقایسه را انجام می‌دهد، جایی که n طول لیست است. اگر احتمال
جستجوی هر عنصر به یک اندازه باشد، جستجوی خطی دارای یک مورد متوسط از (n+1)/2 مقایسه است، اما اگر احتمالات جستجو برای هر
عنصر متفاوت باشد، میانگین مورد می تواند تحت تأثیر قرار گیرد.

```
# can be simply done using 'in' operator
if x in arr:
   print arr.index(x)
 
# If you want to implement Linear Search in Python
def search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
 
    return -1

```

---

۵- متغیرهای محلی و متغیرهای سراسری در پایتون چیست؟ global vs local variables

متغیرهای سراسری: متغیرهایی که خارج از یک تابع یا در فضای global اعلام می شوند، متغیرهای سراسری نامیده می شوند. این
متغیرها توسط هر تابعی در برنامه قابل دسترسی هستند.

متغیرهای محلی: هر متغیری که در داخل یک تابع اعلام شود به عنوان متغیر local شناخته می شود. این متغیر در فضای محلی وجود
دارد نه در فضای global.

---

۶- توصیفگرها چیست؟ descriptors

توصیفگرها در نسخه 2.2 به پایتون معرفی شدند. آنها به توسعه دهنده توانایی اضافه کردن ویژگی های مدیریت شده به اشیاء را می
دهند.( managed attributes to objects) روش های مورد نیاز برای ایجاد یک توصیفگر، __get__، __set__ و __delete__ هستند. اگر
هر یک از این روش ها را تعریف کنید، یک توصیفگر ایجاد کرده اید.

---

۷- آیا پایتون دستور switch-case دارد؟

در پایتون قبل از 3.10، دستور switch-case نداریم. در اینجا، می توانید یک تابع سوئیچ برای این منظور بنویسید. در غیر این
صورت، می توانید از مجموعه ای از عبارات if-elif-else استفاده کنید. برای پیاده‌سازی تابعی برای انجام این کار، احتمالا از
دیکشنری استفاده می کنیم.

```
def switch_demo(argument):
    switcher = {
        1: "January",
        2: "February",
        3: "March",
        4: "April",
        5: "May",
        6: "June",
        7: "July",
        8: "August",
        9: "September",
        10: "October",
        11: "November",
        12: "December"
    }
    print switcher.get(argument, "Invalid month")

```

در سال ۲۰۲۱ پایتون در ورژن 3.10 عبارت match-case را معرفی کرد. برای مثال:

```
def f(x):
    match x:
        case 'a':
            return 1
        case 'b':
            return 2

```

عبارت match-case بسیار قدرتمندتر از این مثال ساده است.

---

۸- چه زمانی از tuple, list, dictionary استفاده می کنیم؟

از tuple زمانی که یک مجموعه از داده هایی که تغییر نخواهند کرد استفاده می کنیم.

از list زمانی که یک مجموعه از داده هایی که تغییر خواهند کرد استفاده میکنیم.

زمانی که می‌خواهید جفت‌هایی از دو مورد را به هم مرتبط کنید، از dictionary استفاده میکنیم.

---

۹- ایندکس منفی در پایتون به چه معنی است؟

ایندکس اعداد منفی به این معنی است که شما به جای چپ، از راست می‌شمارید. بنابراین، list[-1] به آخرین عنصر اشاره می کند.

---

۱۰- توابع Lambda در پایتون چیست؟

یک تابع Lambda یک تابع ناشناس کوچک است. یک تابع Lambda می تواند هر تعداد آرگومان را بگیرد، اما فقط می تواند یک عبارت
داشته باشد. (many arguments but only one expression)

```
x = lambda a : a + 10
print(x(5)) # Output: 15

```

--- 

# سطح Mid

۱۱- نحوه عملکرد مدیریت حافظه پایتون را توضیح دهید؟

پایتون - مانند سی شارپ، جاوا و بسیاری از زبان های دیگر - به جای مدیریت دستی حافظه از garbage collection استفاده می کند.
ما فقط آزادانه object را ایجاد می کنیم و memory manager به صورت دوره ای (یا زمانی که به طور خاص آن را هدایت می کنیم) به
دنبال object هایی می گردد که دیگر توسط برنامه شما referenced داده نمی شود.

اگر میخواهید یک شیء را نگه دارید، کافی ایست یک instance از آن نگه دارید. اگر میخواهید شیء آزاد شود تمام referenced هایی
که به آن شیء دارید را حذف کنید.

---

۱۲- چرا از عبارت pass استفاده می کنیم؟

پایتون اجازه اینکه یک بلاک کد خالی باشد را نمیدهد. با این حال، زمانی که در حال طراحی کلاسی هستیم و نیاز داشته باشیم یک
قسمت خالی باشد می توانیم از pass استفاده کنیم. زمان هایی زیادی وجودد دارد که ما میتونیم از pass استفاده کنیم.

```
class MyClass(object):
    def meth_a(self):
        pass

    def meth_b(self):
        print "I'm meth_b"

```

اگر بخواهید پاس را حذف کنید، کد اجرا نمی شود و با یک خطا مواجه می شوید:

```
IndentationError: expected an indented block

```

مثال‌ دیگری که می‌توانیم از paas استفاده کنیم:

نادیده گرفتن (همه یا) نوع خاصی از استثناها

---

۱۳- دکوراتورها در پایتون چیست؟

در پایتون، توابع first class objects هستند، به این معنی که:

توابع object هستند. آنها می توانند refrence داده شوند، به یک متغیر assign شوند و یا مقدار خروجی یک تابع دیگر باشند.
توابع را می توان در داخل تابع دیگری تعریف کرد و همچنین می تواند به عنوان آرگومان به تابع دیگری ارسال شود.

دکوراتور ها به ما اجزاه می دهند تا رفتار و عملکرد یک تابع را با استفاده از یک wrapper تغییر بدیم.

دکوراتور ها ابزار بسیار قدرتمند و مفیدی در پایتون هستند زیرا به برنامه نویسان اجازه می دهد تا رفتار تابع یا کلاس را
تغییر دهند.

```
@gfg_decorator
def hello_decorator(): 
    print("Gfg") 
  
'''Above code is equivalent to:
  
def hello_decorator(): 
    print("Gfg") 
      
hello_decorator = gfg_decorator(hello_decorator)'''

```

--- 

۱۴- متدهای Dunder/Magic/Special در پایتون چیست؟ چند تا را نام ببرید.

متدهای Dunder (برگرفته از دو خط)، روش‌های از پیش تعریف‌شده special/magic در پایتون هستند، با نام‌هایی که با زیرخط دوتایی
شروع و پایان می‌یابند. هیچ چیز واقعاً جادویی در مورد آنها وجود ندارد. نمونه هایی از این موارد عبارتند از:

```
__init__ - constructor
__str__, __repr__ - object representation (casting to string, printing)
__len__, __next__... - generators
__enter__, __exit__ - context managers
__eq__, __lt__, __gt__ - operator overloading
```

---

۱۵- منظور از Monkey Patching چیست؟ و آیا ایده خوبی است؟

منظور از Monkey Patching تغییر رفتار یک تابع یا یک object پس از تعریف کردن آن است. مثلا:

```
import datetime
datetime.datetime.now = lambda: datetime.datetime(2012, 12, 12)

```

بیشتر اوقات این یک ایده بسیار وحشتناک است - معمولاً بهتر است همه چیز به همون روشی که تعریف شده اند استفاده شوند. . یکی
از دلایلی که از Monkey Patching استفاده می کنیم TEST کردن است. پکیج mock یکی از بهترین پکیج ها در هنگام تست نوشتن و تست
کردن می باشد.

---

۱۶- پایتون with statement برای چه طراحی شده است؟

با استفاده از دستور With میتوانیم Exception را با encapsulation مدیریت میکنیم. و بهش context managers هم گفته می شود.

به عنوان مثال، عبارت open به خودی خود یک context manager هستش که این امکان را میده یک فایل را باز کنیم و تا زمانی که در
داخل دستورات with باشیم فایل را باز نگه میداره، و به محض اینکه از بلاک خروج کنیم، فایل را میبندد.

```
with open("foo.txt") as foo_file:
    data = foo_file.read()

```

```
from contextlib import nested
with nested(A(), B(), C()) as(X, Y, Z):
    do_something()


```

```
with open('data') as input_file, open('result', 'w') as output_file:
    for line in input_file:
        output_file.write(parse(line))

```

```
lock = threading.Lock()
with lock: #Critical section of code

```

--- 

۱۷- استثنا UnboundLocalError و نحوه اجتناب از آن را توضیح دهید؟ مسئله:

```
>>> x = 10
>>> def foo():
...     print(x)
...     x += 1

```

و خروجی مثل زیر خواهد بود:

```
>>> foo()
Traceback (most recent call last):
  ...
UnboundLocalError: local variable 'x' referenced before assignment

```

زمانی که عملیات assignment را درون یک scope برای یک متغیر انجام می دهیم اون variable تبدیل به متغیر local می شود و هر
اسم مشابهی که خارج از scope وجود داشته باشد را shadow می کند. از آنجایی که آخرین دستور در foo مقدار جدیدی را به x اختصاص
می دهد، کامپایلر آن را به عنوان یک متغیر local تشخیص می دهد. در نتیجه زمانی که print(x) قبلی سعی می کند uninitialized
local variable را چاپ کند یک خطا ایجاد می شود.

```
>>> x = 10
>>> def foobar():
...     global x
...     print(x)
...     x += 1
>>> foobar()
10

```

--- 

۱۸- منظور از Pickling و Unpicking چیست؟

پیکل pickle: الگوریتم قدرتمند برای serializing و deserializing کردن ساختار یک object در پایتون است.

منظور از pickling: فرآیندی است که طی آن یک object پیاتون به صورت hierarchy به stream byte تبدیل می شود.

منظور از unpickling: عملیات معکوس است که به موجب آن یک stream بایت دوباره به صورت hierarchy تبدیل به object می شود.

```
>>> import random 
>>> import pickle 
>>> num_list = [random.random() for _ in range(10_000)] 
>>> len(num_list) 
10000 
>>> num_list[:3] 
[0.4877162104023087, 0.23514961430367143, 0.683895941250586] 
>>> with open('nums.out', 'wb') as f: 
...     pickle.dump(num_list, f) 
... 
>>> with open('nums.out', 'rb') as f: 
...     copy_of_nums_list = pickle.load(f) 
... 
>>> copy_of_nums_list[:3] 
[0.4877162104023087, 0.23514961430367143, 0.683895941250586] 
>>> num_list == copy_of_nums_list 
True 

```

--- 

۱۹- از **kwargs و *args چه زمانی استفاده میکنیم؟ توضیح دهید

زمانی که مطمئن نیستیم چند آرگومان قرار است به یک تابع ارسال شود، یا اگر می خواهیم یک لیست ذخیره شده یا چند آرگومان را به
یک تابع ارسال کنیم، از *args استفاده می کنیم.

```
>>> def print_everything(*args):
        for count, thing in enumerate(args):
...         print( '{0}. {1}'.format(count, thing))
...
>>> print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage

```

از **kwargs زمانی استفاده می شود که نمی دانیم چند keyword arguments به یک تابع ارسال می شود، یا می توان از آن برای ارسال
مقادیر یک dictionary به عنوان keyword arguments استفاده کرد.

```
>>> def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print( '{0} = {1}'.format(name, value))
...
>>> table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit
```

---

۲۰- منظور از self چیست؟

ارگومان SELF به خود instance از یک object اشاره میکند. در اکثر زبان های برنامه نویسی شی گرا این پارامتر به صورت مخفی
توسط خود شی که ایجاد شده ارسال می شود.

فرض کنید یک کلاس ClassA دارید که حاوی متدی است که به صورت زیر تعریف شده است:

```
def methodA(self, arg1, arg2): #do something

```

و object A یک instance از کلاس هستش. حالا زمانی که ObjectA.methodA(arg1, arg2) را صدا بزنیم، پایتون به صورت داخلی آن را
مثل زیر تبدیل می کند:

```
ClassA.methodA(ObjectA, arg1, arg2)

```

و پارامتر self به خود object اشاره می کند.

--- 

