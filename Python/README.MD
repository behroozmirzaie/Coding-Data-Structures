# سطح junior

۱- چند ویژگی پایتون را نام ببرید؟

پایتون یک زبان مفسری (interpreted language) است. بدان معناست که برخلاف زبان‌هایی مانند C و انواع آن، پایتون قبل از اجرا
نیازی به کامپایل ندارد. سایر زبان های تفسیری عبارتند از PHP و Ruby.

پایتون به صورت Dynamically Typed است، به این معنی که شما نیازی به بیان انواع متغیرها در هنگام تعریف آنها یا هر چیز دیگری
ندارید. می توانید کارهایی مانند x=111 و سپس x="I'm a string" را بدون خطا انجام دهید

پایتون برای برنامه نویسی شی گرا مناسب است زیرا امکان تعریف کلاس ها به همراه composition و inheritance را فراهم می کند.
پایتون مشخص‌کننده‌های دسترسی ندارد (مانند public, private)، توجیه این نکته به این صورت است که "ما همه در اینجا بزرگسال
هستیم". "we are all adults here"

در پایتون، توابع اشیاء درجه یک هستند(functions are first-class objects). بدان معنی است که می توان آنها را به متغیرها
نسبت داد، از توابع دیگر برگرداند و به توابع منتقل کرد. کلاس ها نیز اشیاء درجه یک هستند.

نوشتن کد در پایتون سریع است اما اجرای آن اغلب کندتر از زبان های کامپایل شده است.

---


۲- چگونه یک string را modify میکنید؟

شما نمی توانید زیرا رشته ها تغییر ناپذیر(immutable) هستند. در اکثر مواقع، باید کارکتر هایی که مدر نظر هستند را جدا کرده
و یک لیست جدید از آنها بسازیم و در صورت نیاز آنها را تبدیل به رشته کنیم.

```python
>>> s = list("Hello zorld")
>>> s
['H', 'e', 'l', 'l', 'o', ' ', 'z', 'o', 'r', 'l', 'd']
>>> s[6] = 'W'
>>> s
['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
>>> "".join(s)
'Hello World'
```

---

۳- انواع built-in types در پایتون چیست؟

نوع های تغییر ناپذیر

اعداد: int, float, complex

دنباله ها: str, tuple, frozenset, bytes

نوع های تغییر پذیر

انواع list, set, dict, class, …

این موضوع را باید درک کنید که python تمام اینها را به عنوان object معرفی می کند.

---

۴- توضیح دهید که جستجوی خطی (متوالی) Linear چیست و چه زمانی می توانیم از آن استفاده کنیم؟

جستجوی خطی (متوالی) همه عناصر ممکن را در یک آرایه به صورت پشت سرهم بررسی می کند و هر کدام از عناصر را با عنصر مورد نظر
مقایسه می کند. ممکن است تا عملیات O(n) طول بکشد، که در آن N اندازه یک آرایه است.

در موارد زیر میتوان استفاده کرد:

عملیات جستجو را فقط یک بار انجام می دهید.

امکان rearrange کردن عناصر آرایه را نداریم و هیچ گونه memory اضافه ای نداریم.

اندازه array کوچک است. یا کلا performance برای ما اهمیت ندارد.

حتی اگر در تئوری دیگر الگوریتم‌های جستجو ممکن است سریع‌تر از جستجوی خطی باشند (مثلاً جستجوی دودویی)، در عمل حتی در
آرایه‌های با اندازه متوسط (حدود 100 مورد یا کمتر) ممکن است استفاده ازهر روش دیگری غیرممکن باشد. در آرایه‌های بزرگ‌تر،
تنها زمانی استفاده از روش‌های جستجوی سریع‌تر دیگر منطقی است که داده‌ها به اندازه کافی بزرگ باشند، زیرا زمان اولیه برای
آماده‌سازی (مرتب‌سازی) داده‌ها با بسیاری از جستجوهای خطی قابل مقایسه است.

زمانی که نمیدونیم دقیقا دنبال چه چیزی میگردیم.

جستجوی خطی در بدترین linear time انجام می‌شود و حداکثر n مقایسه را انجام می‌دهد، جایی که n طول لیست است. اگر احتمال
جستجوی هر عنصر به یک اندازه باشد، جستجوی خطی دارای یک مورد متوسط از (n+1)/2 مقایسه است، اما اگر احتمالات جستجو برای هر
عنصر متفاوت باشد، میانگین مورد می تواند تحت تأثیر قرار گیرد.

```python
# can be simply done using 'in' operator
if x in arr:
   print arr.index(x)
 
# If you want to implement Linear Search in Python
def search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
 
    return -1

```

---

۵- متغیرهای محلی و متغیرهای سراسری در پایتون چیست؟ global vs local variables

متغیرهای سراسری: متغیرهایی که خارج از یک تابع یا در فضای global اعلام می شوند، متغیرهای سراسری نامیده می شوند. این
متغیرها توسط هر تابعی در برنامه قابل دسترسی هستند.

متغیرهای محلی: هر متغیری که در داخل یک تابع اعلام شود به عنوان متغیر local شناخته می شود. این متغیر در فضای محلی وجود
دارد نه در فضای global.

---

۶- توصیفگرها چیست؟ descriptors

توصیفگرها در نسخه 2.2 به پایتون معرفی شدند. آنها به توسعه دهنده توانایی اضافه کردن ویژگی های مدیریت شده به اشیاء را می
دهند.( managed attributes to objects) روش های مورد نیاز برای ایجاد یک توصیفگر، __get__، __set__ و __delete__ هستند. اگر
هر یک از این روش ها را تعریف کنید، یک توصیفگر ایجاد کرده اید.

---

۷- آیا پایتون دستور switch-case دارد؟

در پایتون قبل از 3.10، دستور switch-case نداریم. در اینجا، می توانید یک تابع سوئیچ برای این منظور بنویسید. در غیر این
صورت، می توانید از مجموعه ای از عبارات if-elif-else استفاده کنید. برای پیاده‌سازی تابعی برای انجام این کار، احتمالا از
دیکشنری استفاده می کنیم.

```python
def switch_demo(argument):
    switcher = {
        1: "January",
        2: "February",
        3: "March",
        4: "April",
        5: "May",
        6: "June",
        7: "July",
        8: "August",
        9: "September",
        10: "October",
        11: "November",
        12: "December"
    }
    print switcher.get(argument, "Invalid month")

```

در سال ۲۰۲۱ پایتون در ورژن 3.10 عبارت match-case را معرفی کرد. برای مثال:

```python
def f(x):
    match x:
        case 'a':
            return 1
        case 'b':
            return 2

```

عبارت match-case بسیار قدرتمندتر از این مثال ساده است.

---

۸- چه زمانی از tuple, list, dictionary استفاده می کنیم؟

از tuple زمانی که یک مجموعه از داده هایی که تغییر نخواهند کرد استفاده می کنیم.

از list زمانی که یک مجموعه از داده هایی که تغییر خواهند کرد استفاده میکنیم.

زمانی که می‌خواهید جفت‌هایی از دو مورد را به هم مرتبط کنید، از dictionary استفاده میکنیم.

---

۹- ایندکس منفی در پایتون به چه معنی است؟

ایندکس اعداد منفی به این معنی است که شما به جای چپ، از راست می‌شمارید. بنابراین، list[-1] به آخرین عنصر اشاره می کند.

---

۱۰- توابع Lambda در پایتون چیست؟

یک تابع Lambda یک تابع ناشناس کوچک است. یک تابع Lambda می تواند هر تعداد آرگومان را بگیرد، اما فقط می تواند یک عبارت
داشته باشد. (many arguments but only one expression)

```python
x = lambda a : a + 10
print(x(5)) # Output: 15

```

--- 

# سطح Mid

۱- نحوه عملکرد مدیریت حافظه پایتون را توضیح دهید؟

پایتون - مانند سی شارپ، جاوا و بسیاری از زبان های دیگر - به جای مدیریت دستی حافظه از garbage collection استفاده می کند.
ما فقط آزادانه object را ایجاد می کنیم و memory manager به صورت دوره ای (یا زمانی که به طور خاص آن را هدایت می کنیم) به
دنبال object هایی می گردد که دیگر توسط برنامه شما referenced داده نمی شود.

اگر میخواهید یک شیء را نگه دارید، کافی ایست یک instance از آن نگه دارید. اگر میخواهید شیء آزاد شود تمام referenced هایی
که به آن شیء دارید را حذف کنید.

---

۲- چرا از عبارت pass استفاده می کنیم؟

پایتون اجازه اینکه یک بلاک کد خالی باشد را نمیدهد. با این حال، زمانی که در حال طراحی کلاسی هستیم و نیاز داشته باشیم یک
قسمت خالی باشد می توانیم از pass استفاده کنیم. زمان هایی زیادی وجودد دارد که ما میتونیم از pass استفاده کنیم.

```python
class MyClass(object):
    def meth_a(self):
        pass

    def meth_b(self):
        print "I'm meth_b"

```

اگر بخواهید پاس را حذف کنید، کد اجرا نمی شود و با یک خطا مواجه می شوید:

```python
IndentationError: expected an indented block

```

مثال‌ دیگری که می‌توانیم از paas استفاده کنیم:

نادیده گرفتن (همه یا) نوع خاصی از استثناها

---

۳- دکوراتورها در پایتون چیست؟

در پایتون، توابع first class objects هستند، به این معنی که:

توابع object هستند. آنها می توانند refrence داده شوند، به یک متغیر assign شوند و یا مقدار خروجی یک تابع دیگر باشند.
توابع را می توان در داخل تابع دیگری تعریف کرد و همچنین می تواند به عنوان آرگومان به تابع دیگری ارسال شود.

دکوراتور ها به ما اجزاه می دهند تا رفتار و عملکرد یک تابع را با استفاده از یک wrapper تغییر بدیم.

دکوراتور ها ابزار بسیار قدرتمند و مفیدی در پایتون هستند زیرا به برنامه نویسان اجازه می دهد تا رفتار تابع یا کلاس را
تغییر دهند.

```python
@gfg_decorator
def hello_decorator(): 
    print("Gfg") 
  
'''Above code is equivalent to:
  
def hello_decorator(): 
    print("Gfg") 
      
hello_decorator = gfg_decorator(hello_decorator)'''

```

--- 

۴- متدهای Dunder/Magic/Special در پایتون چیست؟ چند تا را نام ببرید.

متدهای Dunder (برگرفته از دو خط)، روش‌های از پیش تعریف‌شده special/magic در پایتون هستند، با نام‌هایی که با زیرخط دوتایی
شروع و پایان می‌یابند. هیچ چیز واقعاً جادویی در مورد آنها وجود ندارد. نمونه هایی از این موارد عبارتند از:

```python
__init__ - constructor
__str__, __repr__ - object representation (casting to string, printing)
__len__, __next__... - generators
__enter__, __exit__ - context managers
__eq__, __lt__, __gt__ - operator overloading
```

---

۵- منظور از Monkey Patching چیست؟ و آیا ایده خوبی است؟

منظور از Monkey Patching تغییر رفتار یک تابع یا یک object پس از تعریف کردن آن است. مثلا:

```python
import datetime
datetime.datetime.now = lambda: datetime.datetime(2012, 12, 12)

```

بیشتر اوقات این یک ایده بسیار وحشتناک است - معمولاً بهتر است همه چیز به همون روشی که تعریف شده اند استفاده شوند. . یکی
از دلایلی که از Monkey Patching استفاده می کنیم TEST کردن است. پکیج mock یکی از بهترین پکیج ها در هنگام تست نوشتن و تست
کردن می باشد.

---

۶- پایتون with statement برای چه طراحی شده است؟

با استفاده از دستور With میتوانیم Exception را با encapsulation مدیریت میکنیم. و بهش context managers هم گفته می شود.

به عنوان مثال، عبارت open به خودی خود یک context manager هستش که این امکان را میده یک فایل را باز کنیم و تا زمانی که در
داخل دستورات with باشیم فایل را باز نگه میداره، و به محض اینکه از بلاک خروج کنیم، فایل را میبندد.

```
with open("foo.txt") as foo_file:
    data = foo_file.read()

```

```python
from contextlib import nested
with nested(A(), B(), C()) as(X, Y, Z):
    do_something()


```

```python
with open('data') as input_file, open('result', 'w') as output_file:
    for line in input_file:
        output_file.write(parse(line))

```

```python
lock = threading.Lock()
with lock: #Critical section of code

```

--- 

۷- استثنا UnboundLocalError و نحوه اجتناب از آن را توضیح دهید؟ مسئله:

```python
>>> x = 10
>>> def foo():
...     print(x)
...     x += 1

```

و خروجی مثل زیر خواهد بود:

```python
>>> foo()
Traceback (most recent call last):
  ...
UnboundLocalError: local variable 'x' referenced before assignment

```

زمانی که عملیات assignment را درون یک scope برای یک متغیر انجام می دهیم اون variable تبدیل به متغیر local می شود و هر
اسم مشابهی که خارج از scope وجود داشته باشد را shadow می کند. از آنجایی که آخرین دستور در foo مقدار جدیدی را به x اختصاص
می دهد، کامپایلر آن را به عنوان یک متغیر local تشخیص می دهد. در نتیجه زمانی که print(x) قبلی سعی می کند uninitialized
local variable را چاپ کند یک خطا ایجاد می شود.

```python
>>> x = 10
>>> def foobar():
...     global x
...     print(x)
...     x += 1
>>> foobar()
10

```

--- 

۸- منظور از Pickling و Unpicking چیست؟

پیکل pickle: الگوریتم قدرتمند برای serializing و deserializing کردن ساختار یک object در پایتون است.

منظور از pickling: فرآیندی است که طی آن یک object پیاتون به صورت hierarchy به stream byte تبدیل می شود.

منظور از unpickling: عملیات معکوس است که به موجب آن یک stream بایت دوباره به صورت hierarchy تبدیل به object می شود.

```python
>>> import random 
>>> import pickle 
>>> num_list = [random.random() for _ in range(10_000)] 
>>> len(num_list) 
10000 
>>> num_list[:3] 
[0.4877162104023087, 0.23514961430367143, 0.683895941250586] 
>>> with open('nums.out', 'wb') as f: 
...     pickle.dump(num_list, f) 
... 
>>> with open('nums.out', 'rb') as f: 
...     copy_of_nums_list = pickle.load(f) 
... 
>>> copy_of_nums_list[:3] 
[0.4877162104023087, 0.23514961430367143, 0.683895941250586] 
>>> num_list == copy_of_nums_list 
True 

```

--- 

۹- از **kwargs و *args چه زمانی استفاده میکنیم؟ توضیح دهید

زمانی که مطمئن نیستیم چند آرگومان قرار است به یک تابع ارسال شود، یا اگر می خواهیم یک لیست ذخیره شده یا چند آرگومان را به
یک تابع ارسال کنیم، از *args استفاده می کنیم.

```python
>>> def print_everything(*args):
        for count, thing in enumerate(args):
...         print( '{0}. {1}'.format(count, thing))
...
>>> print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage

```

از **kwargs زمانی استفاده می شود که نمی دانیم چند keyword arguments به یک تابع ارسال می شود، یا می توان از آن برای ارسال
مقادیر یک dictionary به عنوان keyword arguments استفاده کرد.

```python
>>> def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print( '{0} = {1}'.format(name, value))
...
>>> table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit
```

---

۱۰- منظور از self چیست؟

ارگومان SELF به خود instance از یک object اشاره میکند. در اکثر زبان های برنامه نویسی شی گرا این پارامتر به صورت مخفی
توسط خود شی که ایجاد شده ارسال می شود.

فرض کنید یک کلاس ClassA دارید که حاوی متدی است که به صورت زیر تعریف شده است:

```python
def methodA(self, arg1, arg2): #do something

```

و object A یک instance از کلاس هستش. حالا زمانی که ObjectA.methodA(arg1, arg2) را صدا بزنیم، پایتون به صورت داخلی آن را
مثل زیر تبدیل می کند:

```python
ClassA.methodA(ObjectA, arg1, arg2)

```

و پارامتر self به خود object اشاره می کند.

--- 


۱۱- تفاوت append و extend در لیست ها چیست؟

اول) append یک المنت به لیست اضافه میکند.

دوم) extend لیست اول را با یک لیست دیگر ادغام میکنه. (البته هر iterable object ای میتونه باشه نه فقط خود لیست)

```python

x = [1, 2, 3]
x.append([4, 5])
print (x)
# [1, 2, 3, [4, 5]]

x = [1, 2, 3]
x.extend([4, 5])
print (x)
# [1, 2, 3, 4, 5]

```

۱۲- منظور از virtualenvs چیست؟

چیزی است که توسعه دهندگان پایتون آن را محیط ایزوله برای توسعه، اجرا، اشکال زدایی کد پایتون می نامند.

برای جداسازی مفسر پایتون با مجموعه ای از کتابخانه ها و تنظیمات استفاده می شود.

با استفاده از پیپ، امکان توسعه، استقرار و اجرای چندین برنامه در یک هاست را فراهم می کند که هر کدام دارای نسخه مفسر
پایتون و مجموعه جداگانه ای از کتابخانه ها هستند.

```python
python3 -m venv /path/to/new/virtual/environment

```

--- 

۱۳- منظور از callable چیست؟

الف) یک callable هر چیزی است که قابل صدا زدن باشد (can be called)

ب) یک شیء قابل call به شما امکان می دهد از پرانتز ( ) استفاده کنید و در نهایت برخی از پارامترها را مانند توابع ارسال
کنید.

هر وقت که یک تابع میسازیم پایتون یک آبجکت callable میسازد. در مثال زیر، میتونیم تابع func را به دو طریق define کنیم(مثل
هم هستند)

```python
class a(object):
    def __call__(self, *args):
        print 'Hello'

func = a()

# or ... 
def func(*args):
    print 'Hello'

```

--- 

۱۴- آیا امکان داشتن static method ها در پایتون وجود دارد؟

بله استفاده از دکوریتور @staticmethod

```python
class MyClass(object):
    @staticmethod
    def the_static_method(x):
        print x

MyClass.the_static_method(2) # outputs 2

```

--- 

۱۵ - منظور از مقدار None چیست؟

از None معمولا برای نشان دادن "خالی" و یا "هیچی اینجا نیست" استفاده می شود.

مثلا اگر تابعی بنویسید و آن تابع مقداری را برنگرداند None برگردانده می شود.

مثال دیگر استفاده از None برای مقادیر پیش فرض است. این تمرین خوب برنامه نویسی است که از اشیاء قابل تغییر به عنوان مقادیر
پیش فرض استفاده نکنید. در عوض، از None به عنوان مقدار پیش فرض استفاده کنید و در داخل تابع، بررسی کنید که آیا پارامتر
None است یا خیر و یک لیست/dictionary/ یا هر چیز دیگه ای که هست جدید ایجاد کنید.

```python
def foo(mydict=None):
    if mydict is None:
        mydict = {}  # create a new dict for local namespace

```

--- 

۱۶- این مقدار دهی را توضیح دهید: x = y or z

```python
x = a or b

```

اگر bool(a) مقدار False را برگرداند، به x مقدار b اختصاص داده می شود.

---- 

۱۷- توضیح دهید که چگونه از Slicing در پایتون استفاده میکنیم.

به راحتی :D

```python
a[start:stop]  # items start through stop-1
a[start:]      # items start through the rest of the array
a[:stop]       # items from the beginning through stop-1
a[:]           # a copy of the whole array
```

مقدار step نیز وجود دارد که می تواند با هر یک از موارد بالا استفاده شود:

```python
a[start:stop:step] # start through not past stop, by step

```

نکته کلیدی که باید به خاطر داشته باشید این است که مقدار :stop اولین مقداری را نشان می دهد که در slice انتخاب نشده است.
بنابراین، تفاوت بین start و stop تعداد عناصر انتخاب شده است.

نمودار هنری ASCII ابزاری مفید برای به خاطر سپردن نحوه کار اسلایدها است:

```
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
```

---

# senior سطح

۱- لطفا Closures را توضیح دهید.

اشیاء دیتاهایی هستند که همراه با method ها هستند، closures توابعی هستند که با data همراه هستند. (معنی همراه اینجا attach
هستش)

روش اتصال داده‌ها به یک تابع بدون ارسال آن‌ها به عنوان پارامتر، Closure نامیده می‌شود.

```python
def make_counter():
    i = 0
    def counter(): # counter() is a closure
        nonlocal i
        i += 1
        return i
    return counter

c1 = make_counter()
c2 = make_counter()

print (c1(), c1(), c2(), c2())
# -> 1 2 1 2

```

---

۲- چرا متد های private در پایتون واقعا private نیستند؟

صورت مسئله:

پایتون با استفاده از ۲ تا underscore این امکان را میده که توابع و متغیر های private تعریف کنیم.
مثل ``` __myPrivateMethod() ``` این را تشریح کنید لطفا:

```python
>>> class MyClass:
...     def myPublicMethod(self):
...             print 'public method'
...     def __myPrivateMethod(self):
...             print 'this is private!!'
... 
>>> obj = MyClass()
>>> obj.myPublicMethod()
public method
>>> obj.__myPrivateMethod()
Traceback (most recent call last):
  File "", line 1, in 
AttributeError: MyClass instance has no attribute '__myPrivateMethod'
>>> dir(obj)
['_MyClass__myPrivateMethod', '__doc__', '__module__', 'myPublicMethod']
>>> obj._MyClass__myPrivateMethod()
this is private!!
```

جواب:

به صورت خلاصه، با استفاده از name scrambling اطمینان پیدا میکنیم که subclass ها به صورت اتفاقی متدها و variable هایی که
private هستند را override نکنند. این مورد برای جلوگیری از دسترسی عمومی طراحی نشده. (It's not designed to prevent
deliberate access from outside.)

به طور دقیق، متد هایی که به صورت private تعریف میشوند خارج از class در دسترس هستند فقط به راحتی نیست :D. هیچ چیزی در
پایتون به صورت واقعی private نیست.

---

۳- تفاوت بین module پایتون و package پایتون چیست؟

هر فایل پایتون یک ماژول است، نام فایل بدون پسوند py هستش.

```python
import my_module

```

یک package مجموعه ای module ها است. زمانی که module یک فایل پایتون است، یک package یک directory از module های پایتونی به
همراه یک فایل init.py اضافی است. برای تشخیص یک package از یک directory از init.py استفاده میکنیم. Package ها را میتونیم
توی هر عمقی به صورت تو در تو قرار بدیم، به شرط اینکه دایرکتوری مربوطه حاوی فایل init.py خودش باشد.

بسته ها packages نیز ماژول هستند. آنها فقط بسته بندی متفاوتی دارند. آنها از ترکیب یک دایرکتوری به علاوه فایل init.py
تشکیل می شوند. آنها ماژول هایی هستند که توانایی نگه داری ماژول های دیگر را هم دارند.

```python
from my_package.timing.danger.internets import function_of_love

```

--- 

۴- GIL چیست ؟

پایتون ساختاری به نام Global Interpreter Lock به صورت مخفف (GIL) دارد. GIL به شما اطمینان می دهد که فقط یکی از thread
های شما در هر لحظه می تواند اجرا شود. یک thread ابتدا GIL را میگیرد، کمی کار میکند، سپس GIL را به thread بعدی منتقل می
کند. این اتفاق خیلی سریع رخ می دهد، بنابراین از نظر چشم انسان این thread ها به صورت parallel اجرا می شوند. اما آنها
واقعا نوبتی از همان هسته CPU استفاده می کنند.

--- 

۵- استفاده از _ (یه دونه underscore) چه هدفی دارد؟

استفاده از _ در پایتون دارای چهار کاربرد معمولی است:

برای نگهداری نتیجه آخرین عبارت (/statement) اجرا شده در یک interactive interpreter session. این سابقه توسط مفسر
استاندارد CPython ایجاد شده است و مفسران دیگر نیز از آن پیروی کرده اند

برای جستجوی ترجمه در i18n، به عنوان مثال زمانی که از gettext استفاده میکنیم مثل
کد: ``` forms.ValidationError(_("Please enter a correct username")) ```

به عنوان یک متغیر همه منظوره که نشان میدهد بخشی از نتیجه یک تابع عمدا نادیده گرفته می شود.(از لحاظ مفهومی، کنار گذاشته
می شود.)

به عنوان بخشی از تعریف تابع( با استفاده از def یا lambda)، جایی که signature ثابت است. این پیاده‌سازی تابع خاص بههمه
پارامتر ها نیاز ندارد مثل: ``` callback = lambda _ : True```

--- 

۶- منظور از MRO در پایتون چیست و چگونه کار میکند؟

ترتیب تفکیک روش Method Resolution Order یا به اختصار (MRO) نشان دهنده روشی است که یک زبان برنامه نویسی یک method یا
attribute را حل می کند. کلاس های پایتون از ارث بری پشتیبانی می کنند و یک کلاس می تواند از کلاس های دیگری ارث بری داشته
باشد. کلاسی که ازش ارث بری می شود را به عنوان Parent یا Superclass می نامند و کلاسی که ارث بری را انجام داده است را بهش
Child یا Subclass می گویند.

در پایتون MRO، ترتیب جستجوی کلاس های پایه را هنگام اجرای یک متد مشخص می کند. ابتدا متد یا attribute در یک کلاس جستجو می
شود و سپس از ترتیبی که در حین ارث بری مشخص کرده ایم پیروی می کند. به این مدل ترتیب Linearization of a class یک کلاس نیز
گفته می شود و مجموعه ای از قوانین را MRO (Method Resolution Order) می گویند.

پایتون جستجوهای متد و attribute را با استفاده از خطی سازی C3 کلاس و والدین آن حل می کند. خطی‌سازی C3 در سلسله‌مراتب‌های
پیچیده وراثت چندگانه نه عمقی است و نه عرضی.

---

۷- نحوه پیاده‌سازی set() در پایتون چگونه است؟

در واقع، set های پایتون چیزی شبیه دیکشنری‌هایی با مقادیر ساختگی (کلیدها اعضای مجموعه هستند) - dictionary with dummy
value ، با برخی بهینه‌سازی (ها) که از این کمبود مقادیر سوءاستفاده می‌کنند، پیاده‌سازی می‌شوند.

بنابراین اساساً یک set از یک hashtable به عنوان ساختار داده زیربنایی خود استفاده می کند. این بررسی عضویت O(1) را توضیح
می دهد، زیرا جستجوی یک آیتم در هشتبل به طور متوسط یک عملیات O(1) است.

همچنین، لازم به ذکر است که وقتی می گویند که set ها دارای بررسی عضویت O(1) هستند، در مورد میانگین این مورد صحبت می کنند.
در بدترین حالت (زمانی که همه مقادیر هش شده با هم برخورد می کنند) - (when all hashed values collide) بررسی عضویت O(n)
است.

--- 

۸- تفاوت staticmethod را با classmethod توضیح دهید.

در واقع Staticmethod یک متدی است که چیزی در مورد کلاس یا instance ای که فراخوانی شده است نمیداند. فقط آرگومان هایی که
تعریف شده است را دریافت می کند.

```python
class C:
    @staticmethod
    def f(arg1, arg2, ...): ... 
```

از سوی دیگر Classmethod یک متدی است که از کلاسی که فرخوانی شده، یا کلاس instance ای که فراخوانی شده به عنوان اولین
آرگومان استفاده می کند. تعریف آن از طریق وراثبت از Subclass پیروی میکند نه کلاس Parent.

```python
class C:
   @classmethod
   def f(cls, arg1, arg2, ...): ...  

```

اگر متد شما به سایر متغیر های و متد های کلاس دسترسی دارند از classmethod استفاده کنید.


--- 

۹- نحوه مدیریت حافظه در پایتون به چه شکل است؟

حافظه پایتون توسط Python private heap space مدیریت می شود. تمام اشیاء و ساختارهای داده پایتون در یک پشته خصوصی قرار
دارند. برنامه نویس به این پشته دسترسی ندارد. مانند سایر زبان های برنامه نویسی پایتون نیز دارای یک Garbage Collector است
که مدیریت حافظه در پایتون را بر عهده دارد.

پایتون همچنین دارای یک garbage collector داخلی است که تمام حافظه استفاده نشده را بازیافت و حافظه را آزاد میکند و حافظه
آزاد شده را در اختیار heap space قرار می دهد.

تخصیص python heap space برای اشیاه پایتون توسط مدیر حافظه پایتون انجام می شود. API مرکزی به برنامه نویس امکان دسترسی به
برخی از ابزارها برای کد نویسی می دهد.

--- 

۱۰- منظور از Metaclass در پایتون چیست؟

یک Metaclass کلاس یک کلاس است.

یک کلاس نحوه رفتار یک instance از کلاس را در هنگام ساخت مشخص می کند.

یک متاکلاس نحوه رفتار یک کلاس را تعریف میکند.

یک کلاس یک instance از metaclass است.

بهش میتونیم class factory هم بگیم.

--- 

# سطح Expert

۱- یک راه حل ساده برای پیاده سازی Singletons بیان کنید.

از metaclass استفاده می کنیم:

```python
class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

#Python2
class MyClass(BaseClass):
    __metaclass__ = Singleton

#Python3
class MyClass(BaseClass, metaclass=Singleton):
    pass

```

به طور کلی استفاده از متاکلاس برای پیاده‌سازی سینگلتون منطقی است. Singleton خاص است زیرا فقط یک بار ایجاد می شود و
متاکلاس راهی است که شما ایجاد یک کلاس را customize می کنید. در صورت نیاز به customize تعاریف کلاس singleton به روش های
دیگر، استفاده از متاکلاس به شما کنترل بیشتری می دهد.

---

۲- 

